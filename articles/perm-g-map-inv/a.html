<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Permutation Symmetry G-Map and Invariance: Sets, Graphs, Simplicial Complexes, and Cell Complexes - Admir Selimovic Research+Dev Index</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Computer+Modern+Serif:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      type="text/css"
      href="https://tikzjax.com/v1/fonts.css"
    />
    <script src="https://tikzjax.com/v1/tikzjax.js"></script>
    <script
      type="text/javascript"
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>

<!-- Single Unified MathJax Configuration -->
<script>
    window.MathJax = {
        tex: {
            inlineMath: [
                ["$", "$"],
                ["\\(", "\\)"]
            ],
            displayMath: [
                ["$$", "$$"],
                ["\\[", "\\]"]
            ],
            tags: 'ams',
            packages: { '[+]': ['ams'] }
        },
        startup: {
          // other MathJax configuration here
          pageReady: () => {
            MathJax.startup.defaultPageReady().then(() => {
              // your code here
              var isMobile = window.matchMedia("only screen and (max-width: 480px)").matches;
      
              if (isMobile) {
                  // Select all MathJax SVG elements
                  var mathJaxSVGs = document.querySelectorAll('.MathJax_SVG');
      
                  // Adjust the size of each SVG's container based on the scale factor
                  var scaleFactor = 0.5;
                  mathJaxSVGs.forEach(function(svg) {
                      // Get the size of the SVG element
                      var rect = svg.getBoundingClientRect();
      
                      // Calculate the new size based on the scale factor
                      var adjustedHeight = rect.height * scaleFactor;
      
                      // Set the new size for the SVG container
                      svg.style.height = adjustedHeight + 'px';
      
                      // You might also need to adjust the parent container of the SVG, depending on your DOM structure
                      svg.parentNode.style.height = adjustedHeight + 'px';
      
                      // Apply the scaling transformation
                      svg.style.transform = 'scale(' + scaleFactor + ')';
                      svg.style.transformOrigin = '0 0';
                  });
              }
            });
          }
        }
      }
  };
</script>


    <style>
      body {
        font-family: "Roboto", Arial, sans-serif;
        margin: 0;
        padding: 0;
        counter-reset: figure-counter;
        counter-reset: table-counter;
      }

      h1 {
        font-size: 1.3em; /* Change this according to your desired size if needed */
        margin: 0.67em 0; /* Default browser styles for h1 */
        font-weight: normal;
      }

      h1 a {
        text-decoration: none;
        color: #333; /* Set the desired color, this is black for instance */
        font-weight: normal;
        border: none; /* Reset the default border */
        padding: 0; /* Reset the default padding */
      }

      h1 a:hover {
        text-decoration: none;
        font-weight: normal;
      }

      .article-container {
        max-width: 750px; /* Make this consistent with the article-title max-width */
        margin: 0 auto; /* This will center the container */
        padding: 20px 20px 50px 20px; /* Add some right padding to avoid touching the screen's right edge */
      }

      .article-title {
        max-width: 800px; /* Adjust this value if you want the title to break into more or fewer lines */
        margin: 10% 5% 0 20%;
        font-size: 38px;
        text-align: left; /* Align the title to the left */
        padding: 0 20px 0 0; /* Add padding only to the right to avoid touching the screen's right edge */
      }

      .article-content {
        font-size: 22px;
        counter-reset: figure-counter; /* Initializes the counter */
      }

      .article-content p {
        margin-bottom: 20px;
        text-align: justify;
        font-size: 22px;
      }

      .article-content,
      .article-content h3,
      .article-content h4 {
        font-family: "Computer Modern Serif", serif;
      }

      a {
        text-decoration: none;
        color: #333;
      }

      a[href^="#fig-"] {
        color: blue;
      }

      a:hover {
        text-decoration: underline;
      }

      figure {
        text-align: center; /* centers the content */
        margin: 50px 0; /* adds some margin on top and bottom */
        counter-increment: figure-counter;
      }

      figcaption {
        font-style: italic;
        font-size: 0.8em; /* makes the caption slightly smaller than regular text */
        color: #000000; /* makes the caption a bit lighter than regular text */
        padding-top: 10px; /* adds some padding between image and caption */
        margin: 0 10%;
        text-align: justify;
      }

      figcaption::before {
        content: "Figure " counter(figure-counter) ": ";
      }

      table {
        counter-increment: table-counter;
        font-size: 0.8em;
        width: 80%;
        margin: 50px 10%;
        border-collapse: collapse;
      }

      th {
        text-align: left;
        padding: 8px;
      }

      td {
        text-align: left;
        padding: 8px;
      }

      /* Thick line above the header */
      thead tr:first-child {
        border-top: 1pt solid black;
      }

      /* Thin line below the header */
      thead tr:last-child {
        border-bottom: 1px solid black;
      }

      /* Thick line at the bottom of the table */
      tbody tr:last-child {
        border-bottom: 1pt solid black;
      }

      table + figcaption::before {
        content: "Table " counter(table-counter) ": ";
        text-align: justify;
      }

      .article-content img {
        width: 100%;
        max-width: 100%;
      }

      .citation {
        font-size: 0.9em;
        margin-top: 20px;
        padding: 5px 0;
      }

      .citation a {
        color: blue;
      }

      .citation-link {
        text-decoration: none;
        color: blue;
      }

      .citation-link:hover {
        text-decoration: underline;
      }

      .reference {
        color: blue;
        text-decoration: none;
      }

      .references-section {
        margin-top: 40px;
        border-top: 1px solid #ccc;
        padding-top: 20px;
      }

      .references-section h2 {
        font-size: 1.5em;
        margin-bottom: 20px;
      }

      .content p {
        margin-bottom: 1em; // or any other styling you want for paragraphs
      }

      .equation {
        text-align: center;
        position: relative;
      }

      .eq-number {
        position: absolute;
        right: 0;
        top: 50%;
        transform: translateY(-50%);
      }

      .tikz-figure {
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
      }

      a.external-link {
          color: blue;
      }

      pre {
          background-color: #f6f8fa;
          border-radius: 3px;
          padding: 10px;
          font-family: "Courier New", monospace;
          overflow-x: auto;
      }
      code {
          color: #000000; 
      }

      .github-badge img {
          width: 120px; /* Value to set the desired width for the badge */
          transition: background-color 0.3s ease; /* Transition effect for hover */
      }
  
      .github-badge:hover img {
          filter: brightness(90%); /* Slightly darken the badge on hover to indicate it's clickable */
      }

     .badge-container {
          display: inline-block;
      }
      
      .badge {
          height: 20px;
          display: inline-block;
          vertical-align: middle;
      }
      
      @media screen and (max-width: 768px) {
        /* adjust 768px if needed */
        h1 {
          font-size: 1.2em; /* adjust this to the desired size for mobile */
        }
        .article-title {
          margin: 10% 5% 0 5%;
          font-size: 1.3em; /* adjust this to the desired size for mobile */
        }
        .article-content {
          font-size: 1em; /* adjust this to the desired size for mobile */
        }
        .article-content p {
          font-size: 1em; /* adjust this to the desired size for mobile */
        }
        table {
          font-size: 0.6em;
          width: 90%; /* Adjusted for the 5% margins on each side */
          margin: 5% 5% 0 5%;
        }
        .references-section h2 {
          font-size: 1em;
        }
      }


      
    </style>
  </head>

  <body>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        // Auto-numbering for figures
        const figures = document.querySelectorAll(".auto-number-figure");
        figures.forEach((fig, index) => {
          const number = index + 1;
          fig.setAttribute("data-number", number);
        });

        // Auto-numbering for tables
        const tables = document.querySelectorAll("table");
        tables.forEach((table, index) => {
          const number = index + 1;
          table.setAttribute("data-number", number);
        });

        const links = document.querySelectorAll(
          'a[href^="#fig-"], a[href^="#tab-"]'
        );
        links.forEach((link) => {
          const targetId = link.getAttribute("href");
          const targetItem = document.querySelector(targetId);
          if (targetItem) {
            const itemNumber = targetItem.getAttribute("data-number");
            if (targetId.startsWith("#fig-")) {
              link.innerHTML = `Figure ${itemNumber}`;
              link.style.color = "blue";
            } else if (targetId.startsWith("#tab-")) {
              link.innerHTML = `Table ${itemNumber}`;
              link.style.color = "blue";
            }
          }
        });

        // Update citations in the text
        const citationPlaceholders = document.querySelectorAll(".autocite");
        citationPlaceholders.forEach((placeholder) => {
          const refId = placeholder.getAttribute("data-ref");
          const targetCitation = document.querySelector(`#${refId}`);
          if (targetCitation) {
            const authors = targetCitation
              .getAttribute("data-authors")
              .split(",");
            const year = targetCitation.getAttribute("data-year");
            let citationText = `<a href="#${refId}" class="citation-link">(`;
            if (authors.length === 1) {
              citationText += `${authors[0]} ${year}`;
            } else {
              citationText += `${authors[0]} et al. ${year}`;
            }
            citationText += `)</a>`;
            placeholder.innerHTML = citationText;
          }
        });
      });

      // Assign numbers to equations
      let equations = document.querySelectorAll(".equation");
      equations.forEach((equation, index) => {
        equation.querySelector(".eq-number").innerText = `( ${index + 1} )`;
      });
    </script>

    <script>
      document.addEventListener("DOMContentLoaded", function () {
        const content = document.querySelector(".content");
        if (content) {
          const paragraphs = content.innerHTML.split(/\n\s*\n/); // Split content at empty lines
          content.innerHTML = paragraphs
            .map((p) => `<p>${p.trim()}</p>`)
            .join(""); // Wrap each split content in <p> tags
        }
      });
    </script>
    
    <h1><a href="/"> &nbsp;&nbsp;Admir Selimovic Research<sup style="color: #FF0000;">+Dev</sup> Index</a></h1>

    <div class="content">
      <h2 class="article-title">Permutation Symmetry G-Map and Invariance: Sets, Graphs, Simplicial Complexes, and Cell Complexes</h2>
    
      <div class="article-container">
        <div class="article-content">

          <div align="center">
            <img src="assets/perm-g-map-inv-0.png" />
          </div>

          <div class="badge-container">
              <img src="https://img.shields.io/badge/Mathematical%20Study-DAF7A6" alt="Mathematical Study" class="badge">
          </div>


<h3>Sets and graphs</h3>

Graphs offer a versatile and easily analysable structure that extends sets by incorporating relationships between entities. We will explore this domain by considering both the basic structure of sets and the more intricate structure of topological graphs, focusing on permutation group invariance and equivariance.

A set \( S = (V) \) consists of nodes \( V = \{v_1, v_2, \ldots, v_n\}\). A graph \({\Gamma = (V,E)}\), on the other hand, consists of nodes and edges, where \(E \subseteq V \times V\), i.e., edges are a subset of the Cartesian product of the nodes with themselves and form a set of pairs of nodes. In graph theory, edges \(E\) can be represented in an adjacency matrix \(\mathbf{A}\), which is a symmetric matrix where the value of 1 indicates a connection, or edge \((i,j)\), between two nodes \(i\) and \(j\), and 0 otherwise:
\[
a_{i j}= \begin{cases} 1 & \text{ if } (i,j) \in E \\ 0 & \text{ if } (i,j) \notin E \end{cases}
\]

Each node \(v_i\) contains a feature vector \(\mathbf{x}_i\), and these features lie in a channel space \( C = \mathbb{R}^k \). The node features are assembled into a matrix \(\mathbf{X}\) of shape \(n \times k\): \(\mathbf{X} = {(\mathbf{x}_1, \dots, \mathbf{x}_n)}^T\), associating the \(i\)-th row with \(\mathbf{x}_i\).

Although a particular node ordering in the set \(S\) or in the graph \(\Gamma\) is implied, it is essential for our purposes that the output of the neural network remains unaffected by this order. To achieve this, we use permutation-invariant functions capable of distilling an order-independent aggregate from the data. Such functions are fundamental in handling sets or unordered data collections where the element order lacks relevance.

Examples of permutation-invariant functions include statistical measures such as the mean, maximum, and sum. These functions operate on the set of features in a way that ignores their sequence, producing a consistent result.

Let \( G \) be a group acting on the set \( S \) and graph \(\Gamma\), and let \( \rho: G \rightarrow \text{GL}(V) \) be a group representation, where \(\text{GL}(V)\) is the general linear group of invertible matrices over a vector space \( V \). This representation encodes how the elements of \( G \) act on the set, the graph, and any other associated structures like the adjacency matrix and feature matrix.

The required symmetry group \( G = \mathrm{Sym}(M) \) here is the \( n \)-element permutation group. Each element \( g \in G \) represents a permutation. There are \( n! \) such permutations possible.

A function \( f(x) \) is said to be permutation invariant if \(\forall \rho(g) \in G\), \( f(\rho(g) x) = f(x) \). In linear-algebraic terms, \(\rho(g)\) corresponds to an \( n \times n \) matrix or permutation matrix \(\mathbf{X}\). Permutation matrices merely shuffle the rows of another matrix, which, in our case, is the node feature matrix \(\mathbf{X}\). We thus say that \( f(\mathbf{X}) \) is permutation invariant if \(\forall \mathbf{P}\), \( f(\mathbf{PX}) = f(\mathbf{X}) \), i.e., \( f(\mathbf{X}) \) is permutation group equivariant if it does not matter whether the permutation matrix \(\mathbf{P}\) is applied before or after applying the function \( f \); the function should return the same result. This property forms the foundation for designing functions resilient to permutations on sets.

Deep Sets <span class="autocite" data-ref="zaheer2017"></span> is often invoked as a standard way of implementing permutation invariance over sets and as a generic model capable of expressing any other permutation invariant model <span class="autocite" data-ref="wagstaff2019"></span>. 

The standard implementation of a permutation invariant function in a neural network may be expressed as \( f(\mathbf{X}) = \phi(\bigoplus_{i \in V} \psi(\mathbf{x}_i)) \), 
where we compute outputs over the input set given by the node feature matrix \( \mathbf{X} \) by applying a learnable function \( \psi \) to every single node feature vector \( \mathbf{x}_i \), after which we aggregate the resulting vectors. Finally, to predict the outputs, we use another learnable function \( \phi \), applied over the output of the aggregate.
Here, \( \bigoplus \) represents a binary operation that combines two elements in a way that is insensitive to their order; it is any permutation-invariant operator.

Having an additional object — edges \( e_{ij} \) — in graphs means that the permutation matrix does not act only on the nodes, but also on the edges. Permutation invariance over graphs is thus expressed as:
\[
f(\rho(g)x, \rho(g) e_{ij}) = f(x, e_{ij}) \quad \forall \rho(g) \in G .
\]

Edges are represented by an adjacency matrix \( \mathbf{A} \). Permuting \( \mathbf{A} \) implies a permutation of both its rows and its columns. The permutation takes the linear-algebraic form \( \mathbf{PAP}^T \) and the invariance wrt permutation over graphs is expressed as \( f(\mathbf{PX},\mathbf{PAP}^T) = f(\mathbf{X},\mathbf{A}) \).

While permutation invariance is powerful for handling sets as a whole, it is less suitable for operations that depend on the specific position or identity of individual elements within the set.
A permutation-invariant aggregator does not recognise the order or specific identity of elements within a set. If the position or role of an individual node within the set carries important information (e.g., the first element represents a unique identifier), a permutation-invariant function would not consider it.
By treating all nodes equally and without considering their order, a permutation-invariant function might overlook specialised or role-based behaviors of individual nodes. In graph-based models, for instance, some nodes might have specific functions or relationships that are essential to the overall system's behavior. A permutation-invariant aggregator would not allow for this specialised treatment.
In tasks where the sequence or ordering of nodes matters (e.g., time-series data, natural language processing), applying a permutation-invariant function would disrupt the inherent sequence-based relationships between nodes. It would make the function unsuitable for modeling or predicting sequence-dependent phenomena.

For the outputs at the level of a node, we need functions that do not influence the node order. It should be so that permuting the nodes order can be done before or after those functions, such that every single node output can be identified afterward. 
This leads us to the notion of \( G \)-map for the specific case of permutation group \( G = \mathrm{Sym}(M) \). 

We say that \( f(x) \) is permutation group equivariant over sets if 
\[
f(\rho(g)x) = \rho(g) f(x) \quad \forall \rho(g) \in G
\]
In linear-algebraic terms, this corresponds to 
\( \forall \mathbf{P}, f(\mathbf{PX}) = \mathbf{P}f(\mathbf{X}) \), i.e.,
\( f(\mathbf{X}) \) is permutation equivariant if, regardless of what permutation matrix we choose, it does not matter whether \( \mathbf{P} \) is applied before or after applying the function \( f \); it should return the same result.

\( G \)-map wrt permutation over graphs is expressed as:
\[
f(\rho(g)x,  \rho(g) e_{ij}) = \rho(g) f(x, e_{ij}) \quad \forall \rho(g) \in G
\]
which corresponds to as \( f(\mathbf{PX},\mathbf{PAP}^T) = \mathbf{P}f(\mathbf{X},\mathbf{A}) \).


<h3>Simplicial complexes</h3>

Like with sets and graphs, we require a permutation \( G \)-map over simplicial complexes due to the possible relabeling of simplices in the complex.

One approach to permuting a simplicial complex \( K \) of dimension \( k \) is to permute the underlying \( k=0 \) simplices, or vertices. This would induce the permutation of the higher order simplices \( k>0 \). The other approach is to permute all the simplices in \( K \) that are of the same dimension independently, which is the approach we are going to take.

Recall that the boundary operator of a simplex is a linear map \( \partial_k: C_k \rightarrow C_{k-1} \), assigning to each \( k \)-simplex \( \sigma \) in a simplicial complex a \( (k-1) \)-chain \( \partial_k(\sigma) \). This chain is the formal sum of its \( (k-1) \)-dimensional faces with alternating signs, where \( C_k \) is the \( k \)-th chain group of the simplicial complex. 
We denote the collection of all boundary operators of a simplicial complex \( K \) of dimension \( k \) by \( \{\partial_i\}_{i=1}^{k} \).

Now, we can define invariance wrt permutation over simplicial complexes as:
\[
f(\rho(g) x, \rho(g) \{\partial_i\}_{i=1}^{k}) = f(x, \{\partial_i\}_{i=1}^{k}) \quad \forall \rho(g) \in G
\]

\( G \)-map wrt permutation over simplicial complexes is expressed as:
\[
f(\rho(g) x, \rho(g) \{\partial_i\}_{i=1}^{k}) = \rho(g) f(x, \{\partial_i\}_{i=1}^{k}) \quad \forall \rho(g) \in G
\]

<figure id="perm-g-map-sc-diag-1" class="auto-number-figure">
    <img src="assets/perm-g-map-sc-diag-1.png" />
</figure>
          
Recall that the boundary matrix \( \mathbf{B}_k \) represents the boundary operator. \( \mathbf{B}_k \) maps the set of \( k \)-simplices, \( \sigma^k \), to the set of \( (k-1) \)-simplices. In this mapping, each row \( i \) of the matrix corresponds to a unique \( (k-1) \)-dimensional simplex in the boundary of \( \sigma^k \), and each column \( j \) of the matrix corresponds to a unique \( k \)-dimensional simplex \( \sigma^k \). The entry in row \( i \) and column \( j \) of \( \mathbf{B}_k \) is \( +1 \) if \( i \) and \( j \) have the same relative orientations, \( -1 \) if \( i \) and \( j \) have inverse relative orientations, and \( 0 \) if \( j \) does not contain \( i \) as a face. 
\( \mathbf{B}_k \) is a \( (n_{k-1}) \times n_k \) matrix, where \( n_k \) is the number of \( k \)-dimensional simplices in \( K \). 

A simplicial complex \( K \) of dimension \( k \) can be represented by all of its boundary matrices \( \mathbf{B} = (\mathbf{B}_1, \mathbf{B}_2, \dots , \mathbf{B}_k) \). 

Let \( \mathbf{P} = (\mathbf{P}_0, \mathbf{P}_1, \dots , \mathbf{P}_k) \) be a finite ordered sequence of permutation matrices. Permutation of \( \mathbf{B} \) takes the linear-algebraic form:
\[
\mathbf{PB} = ( \mathbf{P}_0 \mathbf{B}_1 \mathbf{P}^{\top}_1, \mathbf{P}_1 \mathbf{B}_2 \mathbf{P}^{\top}_2, \dots , \mathbf{P}_{k-1} \mathbf{B}_k \mathbf{P}^{\top}_k) ,
\]
where \( \mathbf{P}_0 \mathbf{B}_1 \mathbf{P}^{\top}_1 \) denotes a permutation of the rows of \( \mathbf{B}_1 \) by the node permutation matrix \( \mathbf{P}_0 \) and columns by the edge permutation matrix \( \mathbf{P}^{\top}_1 \).

Features of a simplicial complex are given by a collection of feature matrices, \( \mathbf{X} = (\mathbf{X}_0, \mathbf{X}_1, \dots, \mathbf{X}_k) \). Permutation of feature matrices \( \mathbf{X} \) takes the following form:
\( {\mathbf{PX} = ( \mathbf{P}_0 \mathbf{X}_0, \mathbf{P}_1 \mathbf{X}_1, \dots , \mathbf{P}_{k} \mathbf{X}_k)} \).

Thus, we can define permutation invariance wrt simplicial complexes as: 
\[
f(\mathbf{PB},\mathbf{P} \mathbf{X}) =  f(\mathbf{B},\mathbf{X})
\]

Permutation \( G \)-map over simplicial complexes takes the form:
\[
f(\mathbf{PB}, \mathbf{P} \mathbf{X}) = \mathbf{P} f(\mathbf{B},\mathbf{X})
\]

<figure id="perm-g-map-sc-diag-2" class="auto-number-figure">
    <img src="assets/perm-g-map-sc-diag-2.png" style="width: 70%; height: auto;" />
</figure>


<h3>Cell complexes</h3>

Adjacencies and boundary relationships in cell complexes are more intricate to describe compared to graphs or simplicial complexes. Unlike simplicial complexes, cell complexes do not naturally have a hierarchy of faces that lend themselves to a simple matrix representation like boundary matrices. 

Cell complexes are built by gluing cells of various dimensions together. An incidence matrix can be defined to describe how these cells of different dimensions are connected. For a cell complex with cells of dimensions ranging from \(0\) to \(k\), one might define a sequence of incidence matrices \(\mathbf{I} = (\mathbf{I}_0, \mathbf{I}_1, \ldots, \mathbf{I}_{k-1})\), where \(\mathbf{I}_i\) captures the relationships between \(i\)-cells and \((i+1)\)-cells.

In the case where a cell complex consists entirely of cells of the same dimension \(k\), the usual definition of an incidence matrix does not directly apply. A common approach to handle this special case is to define adjacency based on a broader sense of sharing common boundaries. This can be captured by an adjacency matrix \(\mathbf{A}\), where \(a_{ij} = 1\) if the \(i\)-th and \(j\)-th \(k\)-cells share a common boundary, and \(0\) otherwise.

Another approach is to employ a dual complex where vertices correspond to the \(k\)-cells of the original complex, and edges in the dual connect vertices corresponding to adjacent \(k\)-cells in the original. This dual complex can have an adjacency matrix \(\mathbf{A}\) in the usual graph-theoretic sense, providing a matrix representation for adjacency within a uniform dimension cell complex.

Permutation \( G \)-invariance and \( G \)-map can be defined over cell complexes, much like in simplicial complexes. For incidence matrices, the permutation might be expressed through a sequence of permutation matrices \(\mathbf{P} = (\mathbf{P}_0, \mathbf{P}_1, \ldots, \mathbf{P}_{k-1})\), with the transformation given by:
\[
\mathbf{PI} = ( \mathbf{P}_0 \mathbf{I}_0 \mathbf{P}^{\top}_1, \mathbf{P}_1 \mathbf{I}_1 \mathbf{P}^{\top}_2, \ldots, \mathbf{P}_{k-2} \mathbf{I}_{k-1} \mathbf{P}^{\top}_{k-1})
\]
Here, the permutation matrices act on the rows and columns corresponding to the cells they permute.

\( G \)-invariance and \( G \)-map can then be defined analogously to the simplicial complex case, utilising the transformed incidence matrices or adjacency matrices.


          
</div>
        
        <div class="references-section">
          <h2>References</h2>
          <div
            class="citation"
            id="zaheer2017"
            data-authors="Manzil Zaheer, Satwik Kottur, Siamak Ravanbakhsh, Barnabás Póczos, Ruslan Salakhutdinov, Alexander J. Smola"
            data-year="2017"
          >
            Manzil Zaheer, Satwik Kottur, Siamak Ravanbakhsh, Barnabás Póczos, Ruslan Salakhutdinov, Alexander J. Smola.
            <a href="http://arxiv.org/abs/1703.06114"
              >"Deep Sets"</a
            >. CoRR, abs/1703.06114, 2017.
          </div>
          <div
            class="citation"
            id="wagstaff2019"
            data-authors="Edward Wagstaff, Fabian B. Fuchs, Martin Engelcke, Ingmar Posner, Michael A. Osborne"
            data-year="2019"
          >
            Edward Wagstaff, Fabian B. Fuchs, Martin Engelcke, Ingmar Posner, Michael A. Osborne.
            <a href="http://arxiv.org/abs/1901.09006"
              >"On the Limitations of Representing Functions on Sets"</a
            >. CoRR, abs/1901.09006, 2019.
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
